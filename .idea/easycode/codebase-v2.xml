<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="com.obiscr.chatgpt.settings.EasyCodeState">
    <option name="projectFiles" value="$PROJECT_DIR$/src/Ecosystem-exception-task-main/pom.xml;C:/Users/tesa4/IdeaProjects/JavaWoche3/src/main/java/BastiBAufgaben/Geometry/Circle.java;C:/Users/tesa4/IdeaProjects/JavaWoche3/src/main/java/BastiBAufgaben/Geometry/usage.java;C:/Users/tesa4/IdeaProjects/JavaWoche3/src/main/java/BastiBAufgabenShop/meow.java;C:/Users/tesa4/IdeaProjects/JavaWoche3/src/main/java/BastiBAufgabenShop/OnlineShop.java;C:/Users/tesa4/IdeaProjects/JavaWoche3/src/main/java/BastiBAufgabenShop/Produkt.java;C:/Users/tesa4/IdeaProjects/JavaWoche3/src/main/java/BastiBAufgabenShop/Shop.java;C:/Users/tesa4/IdeaProjects/JavaWoche3/src/main/java/BastiBAufgabenShop/usage.java;C:/Users/tesa4/IdeaProjects/JavaWoche3/src/main/java/Maps/Medecine.java;C:/Users/tesa4/IdeaProjects/JavaWoche3/src/main/java/Objektvererbung/Bonus/Flugzeug.java;C:/Users/tesa4/IdeaProjects/JavaWoche3/src/main/java/Objektvererbung/Bonus/Sortierer.java;C:/Users/tesa4/IdeaProjects/JavaWoche3/src/main/java/Objektvererbung/Interfaces/CanBeHifi.java;C:/Users/tesa4/IdeaProjects/JavaWoche3/src/main/java/Objektvererbung/Interfaces/Playable.java;C:/Users/tesa4/IdeaProjects/JavaWoche3/src/main/java/Objektvererbung/Auto.java;C:/Users/tesa4/IdeaProjects/JavaWoche3/src/main/java/Objektvererbung/Einführung.java;C:/Users/tesa4/IdeaProjects/JavaWoche3/src/main/java/Objektvererbung/ElectronicDevice.java;C:/Users/tesa4/IdeaProjects/JavaWoche3/src/main/java/Objektvererbung/Fahrzeug.java;C:/Users/tesa4/IdeaProjects/JavaWoche3/src/main/java/Objektvererbung/InterfacesBenutzen.java;C:/Users/tesa4/IdeaProjects/JavaWoche3/src/main/java/Objektvererbung/media.java;C:/Users/tesa4/IdeaProjects/JavaWoche3/src/main/java/Objektvererbung/MediaController.java;C:/Users/tesa4/IdeaProjects/JavaWoche3/src/main/java/Objektvererbung/Motorrad.java;C:/Users/tesa4/IdeaProjects/JavaWoche3/src/main/java/Objektvererbung/MusicPlayer.java;C:/Users/tesa4/IdeaProjects/JavaWoche3/src/main/java/Objektvererbung/Screen.java;C:/Users/tesa4/IdeaProjects/JavaWoche3/src/main/java/Objektvererbung/VideoPlayer.java;C:/Users/tesa4/IdeaProjects/JavaWoche3/src/main/java/org/example/Main.java;C:/Users/tesa4/IdeaProjects/JavaWoche3/src/main/java/RecordsUndLombock/Course.java;C:/Users/tesa4/IdeaProjects/JavaWoche3/src/main/java/RecordsUndLombock/Destination.java;C:/Users/tesa4/IdeaProjects/JavaWoche3/src/main/java/RecordsUndLombock/EingabeDings.java;C:/Users/tesa4/IdeaProjects/JavaWoche3/src/main/java/RecordsUndLombock/Main.java;C:/Users/tesa4/IdeaProjects/JavaWoche3/src/main/java/RecordsUndLombock/Student.java;C:/Users/tesa4/IdeaProjects/JavaWoche3/src/main/java/RecordsUndLombock/Subject.java;C:/Users/tesa4/IdeaProjects/JavaWoche3/src/main/java/RecordsUndLombock/UniversityService.java;C:/Users/tesa4/IdeaProjects/JavaWoche3/src/main/java/SilvanBonus/Raintrap.java;C:/Users/tesa4/IdeaProjects/JavaWoche3/src/main/java/Streams/Bonuuuus.java;C:/Users/tesa4/IdeaProjects/JavaWoche3/src/main/java/Streams/Streaming.java;C:/Users/tesa4/IdeaProjects/JavaWoche3/src/main/java/Streams/Student.java;C:/Users/tesa4/IdeaProjects/JavaWoche3/src/main/java/trycatch/example.java;C:/Users/tesa4/IdeaProjects/JavaWoche3/src/main/java/Main.java;C:/Users/tesa4/IdeaProjects/JavaWoche3/src/test/java/BastiBAufgaben/Geometry/CircleTest.java;C:/Users/tesa4/IdeaProjects/JavaWoche3/pom.xml" />
    <option name="forceFullIndex" value="false" />
    <option name="fileSummaryMaps" value="{&quot;C:/Users/tesa4/IdeaProjects/JavaWoche3&quot;:&quot;{\&quot;/src/main/java/BastiBAufgabenShop/Produkt.java\&quot;:\&quot;This Java file defines a Produkt (product) class for an online shop application.\\n\\nKey things:\\n\\n- It defines a Produkt class that represents a product in the online shop\\n- Produkt extends the OnlineShop class, inheriting any properties/methods from that parent class\\n- It uses the Lombok @Builder annotation which generates a builder-style constructor for the class\\n- Produkt has two properties:\\n  - name (String) - the name of the product\\n  - price (double) - the price of the product\\n- No methods are defined on the Produkt class itself. It inherits any methods from the parent OnlineShop class.\\n- The @Builder annotation allows easily constructing Produkt objects by specifying the name and price, avoiding issues with nullable/required fields.\\n\\nSo in summary:\\n\\n- Defines a Produkt domain class to represent products\\n- Extends an OnlineShop parent class \\n- Uses Lombok builder pattern for easy object construction\\n- Holds name and price properties for a product\\n- Inherits any methods from OnlineShop parent class\&quot;,\&quot;/src/main/java/Maps/Medecine.java\&quot;:\&quot;This Java file defines a Medecine class that uses a HashMap to store medicine names mapped to their purposes.\\n\\nThe key functions are:\\n\\n- main() - The entry point, it initializes the HashMap, calls other functions, and prints output.\\n\\n- count() - Returns the size/number of entries in the HashMap. \\n\\n- save() - Removes an entry from the HashMap by key, by prompting the user for input.\\n\\n- print() - Prints out all key-value pairs in the HashMap.\\n\\n- name() - Prompts the user for a key, looks it up in the HashMap, and prints the value if found or a message if not found.\\n\\nSo in summary, it:\\n\\n- Defines a HashMap to store medicine name-purpose mappings\\n- Allows adding/removing entries \\n- Counts number of entries\\n- Looks up entries by key\\n- Prints the entire map\\n\\nThe key purpose is to demonstrate basic HashMap usage for storing and retrieving data by key in Java.\&quot;,\&quot;/src/main/java/org/example/Main.java\&quot;:\&quot;This Java file contains a simple \\\&quot;Hello World\\\&quot; style program to demonstrate some basic IntelliJ IDEA features:\\n\\n- It defines a main class called Main with a main method. This is the entry point for the program.\\n\\n- The main method prints a hardcoded string \\\&quot;Hello and welcome!\\\&quot; using System.out.printf(). \\n\\n- It contains a for loop that prints the numbers 1 to 5 using System.out.println().\\n\\n- Comments provide instructions on how to use some IntelliJ features like showing whitespace, auto-fixing code, running the program, and debugging.\\n\\nKey functions:\\n\\n- Defines a Java class with a main method - the basic structure of a Java program\\n- Prints output to the console \\n- Uses a for loop to iterate \\n- Contains comments explaining how to use IntelliJ features\\n- Can be run and debugged directly from within IntelliJ\\n- Demonstrates basic code formatting and syntax highlighting\\n\\nThe purpose is to provide a simple example program to showcase IntelliJ\\u0027s code editing, running and debugging capabilities for new Java developers.\&quot;,\&quot;/src/main/java/Streams/Streaming.java\&quot;:\&quot;This Java file demonstrates the use of Java streams to perform operations on collections.\\n\\nThe key things it does:\\n\\n1. Defines a List of integers and adds some sample values to it.\\n\\n2. Uses stream() to filter the list to only even numbers, collecting the result to a new list. \\n\\n3. Sorts the stream of numbers in the list and collects to a new list.\\n\\n4. Maps each number in the stream to double its value, collecting to a new list. \\n\\n5. Reduces the stream of numbers to a single sum value using the Integer sum reducer.\\n\\n6. ForEach prints each number in the list by consuming the stream. \\n\\n7. Defines a contains method that checks if a string contains a substring, used to test streaming.\\n\\nThe main functions demonstrated are:\\n\\n- Filtering a stream \\n- Sorting a stream\\n- Mapping elements of a stream \\n- Reducing a stream to a single value\\n- ForEach consuming to operate on each element\\n- Defining and calling a method from the stream\\n\\nSo in summary it shows common stream operations like filtering, mapping, reducing as well as consuming streams.\&quot;,\&quot;/src/main/java/BastiBAufgaben/Geometry/Circle.java\&quot;:\&quot;This Java file defines a Circle class that represents a geometric circle.\\n\\nKey functions:\\n\\n- Constructor annotated with @Builder - allows Circle objects to be constructed using a builder pattern\\n\\n- getRadius() and setRadius() - accessors for the circle\\u0027s radius\\n\\n- getDiameter() and setDiameter() - accessors for the circle\\u0027s diameter \\n\\n- getArea() and setArea() - accessors for the circle\\u0027s area\\n\\n- getCircumference() and setCircumference() - accessors for the circle\\u0027s circumference\\n\\n- calculateArea() - calculates and sets the circle\\u0027s area based on the radius\\n\\n- calculateDiameter() - calculates and sets the diameter based on the radius \\n\\n- calculateCircumference() - calculates and sets the circumference based on the radius\\n\\nSo in summary, it defines a Circle class with properties for radius, diameter, area and circumference. It provides getter/setter methods for these properties and calculation methods to dynamically update the derived properties based on changes to the radius.\&quot;,\&quot;/src/main/java/BastiBAufgabenShop/usage.java\&quot;:\&quot;This Java file defines a usage class that demonstrates how to use the OnlineShop class.\\n\\nKey functions:\\n\\n- main() - The entry point of the program that demonstrates usage.\\n\\n- OnlineShop produkte \\u003d new OnlineShop(); - Creates an instance of the OnlineShop class.\\n\\n- Produkt meow1 \\u003d new Produkt.ProduktBuilder()...build(); - Creates a Produkt object using a builder pattern. \\n\\n- OnlineShop.objektHinzufügen() - Adds an object to the OnlineShop. This is demonstrating how to add products to the shop.\\n\\n- System.out.println(produkte); - Prints out the OnlineShop instance, presumably to view the products that were added.\\n\\nSo in summary, it:\\n\\n- Creates an OnlineShop instance \\n- Creates a sample Produkt object\\n- Adds objects to the OnlineShop using objektHinzufügen()\\n- Prints out the OnlineShop to demonstrate the added products\\n\\nIt\\u0027s a simple usage example to demonstrate the basic functionality of creating an online shop, adding products to it, and viewing the shop contents.\&quot;,\&quot;/src/main/java/RecordsUndLombock/Main.java\&quot;:\&quot;This Java file demonstrates the use of Lombok annotations with records:\\n\\n- It defines a Student class with @Value annotation, which makes it an immutable record class. @Value also generates getter methods, toString(), hashCode() and equals() methods.\\n\\n- The Main class has a main() method that creates two Student objects - one using the constructor and one using the builder pattern generated by @Builder. \\n\\n- @Getter annotation on Main class makes all fields accessible via getter methods. \\n\\n- @val is used as a local variable type inference.\\n\\n- It shows that calling withClassroom() on an immutable Student object returns a new instance instead of mutating the original.\\n\\n- It creates a Course object passing the Subject enum to the constructor.\\n\\nKey functions:\\n\\n- Demonstrates immutable record pattern with Lombok annotations \\n- Builder pattern generation for constructing objects\\n- Accessor methods generation with @Getter\\n- Immutability - new instance returned on field change instead of mutation\\n- Local variable type inference with @val\\n- Passing enum to constructor\\n\\nSo in summary, it shows how Lombok can reduce boilerplate code for records/POJOs and generate common methods.\&quot;,\&quot;/src/main/java/Objektvererbung/MediaController.java\&quot;:\&quot;This Java file defines a MediaController class that is used to control playable media objects.\\n\\nKey things:\\n\\n- It is in the Objektvererbung package\\n- It imports the Playable interface from the Interfaces package\\n- It defines a playMedia method that takes a Playable object as a parameter\\n- The playMedia method calls the print method on the Playable object to play/print it\\n- This allows different objects that implement Playable (like Video, Audio etc) to be passed to playMedia and played polymorphically through their common Playable interface.\\n\\nSo in summary:\\n\\n- MediaController class controls playback of media\\n- playMedia method plays a Playable object polymorphically \\n- This allows different media types (Video, Audio etc) to be played via their common Playable interface\\n\\nThe key function is playMedia which allows polymorphic playback of any Playable object. This implements a basic controller to play different media types uniformly via inheritance/interfaces.\&quot;,\&quot;/src/main/java/RecordsUndLombock/Destination.java\&quot;:\&quot;This Java file defines a record class called Destination using Project Lombok.\\n\\nKey things:\\n\\n- It is defined using the @Record annotation from Lombok, which generates boilerplate code for a simple data class.\\n\\n- Destination has two fields - name and country, both Strings. \\n\\n- Lombok will generate:\\n  - Constructor to initialize the fields\\n  - Getter methods for the fields\\n  - toString(), equals(), hashCode() methods\\n  - A static factory method named of()\\n\\n- Destination is meant to represent a simple data record for storing destination name and country. \\n\\n- Instances can be easily created using the generated constructor or of() method. \\n\\n- Fields can be accessed via the generated getters. \\n\\n- Default implementations of toString(), equals() and hashCode() allow Destination objects to be used where those methods are required (printing, comparing, hashing).\\n\\n- It avoids a lot of boilerplate code that would otherwise need to be written by hand for a simple data class.\\n\\nSo in summary, it defines a simple data record class for destinations using Project Lombok annotations to generate common code patterns for value/data classes.\&quot;,\&quot;/src/main/java/RecordsUndLombock/Student.java\&quot;:\&quot;This Java file defines a Student class using Lombok annotations:\\n\\n- @With: Generates constructor, toString, equals and hashCode methods.\\n\\n- @Builder: Generates a builder pattern for constructing Student objects. \\n\\n- @Getter: Generates getter methods for all fields.\\n\\nThe key functions are:\\n\\n- getAge(): Gets the student\\u0027s age.\\n\\n- setAge(): Sets the student\\u0027s age. \\n\\n- getName(): Gets the student\\u0027s name.\\n\\n- setName(): Sets the student\\u0027s name.\\n\\n- getClassroom(): Gets the student\\u0027s classroom number. \\n\\n- setClassroom(): Sets the student\\u0027s classroom number.\\n\\nSo in summary, it defines a Student class with fields for age, name and classroom. Lombok annotations are used to generate common methods like getters/setters, constructor, toString etc. This reduces boilerplate code and makes the class more concise. The @Builder annotation also allows easy construction of Student objects using a builder pattern.\&quot;,\&quot;/src/main/java/Objektvererbung/Auto.java\&quot;:\&quot;This Java file defines an Auto (Car) class that inherits from the Fahrzeug (Vehicle) class.\\n\\nKey things:\\n\\n- Auto extends Fahrzeug, so it inherits all properties and methods from the Fahrzeug class.\\n\\n- It defines an additional property Türen (doors) that is specific to cars. \\n\\n- It has getter and setter methods for the Türen property:\\n\\n  - getTüren() returns the number of doors\\n\\n  - setTüren(int türen) sets the number of doors\\n\\nSo in summary:\\n\\n- Auto is a subclass of Fahrzeug (Vehicle)\\n- It inherits all functionality from Fahrzeug \\n- It adds an additional property Türen (doors)\\n- It provides getter and setter methods for the Türen property\\n\\nThe key functions are:\\n\\n- getTüren() - Gets the number of doors\\n- setTüren(int) - Sets the number of doors\\n\\nSo it defines a Car class that inherits from Vehicle and adds doors functionality through getter/setter methods.\&quot;,\&quot;/src/main/java/Objektvererbung/Bonus/Flugzeug.java\&quot;:\&quot;This Java file defines a Flugzeug (airplane) class.\\n\\nKey things it does:\\n\\n- Defines a Flugzeug class in the Objektvererbung.Bonus package\\n\\n- It has a private String field called zc to store some data (likely registration code)\\n\\n- It has a getter and setter method for the zc field - getZc() and setZc()\\n\\n- The toString() method is overridden to return a String representation of the Flugzeug object including the zc value\\n\\nSo in summary, it defines a basic Flugzeug class with:\\n\\n- A private data field \\n- Getter and setter for that field\\n- toString() method to represent the object as a String\\n\\nThis looks like it is setting up a basic Flugzeug class to store registration code data that can then be reused/extended in other classes through inheritance. The getter/setter/toString are standard functions needed to access and represent the data in the class.\&quot;,\&quot;/src/main/java/RecordsUndLombock/EingabeDings.java\&quot;:\&quot;This Java file defines a simple EingabeDings class to demonstrate the use of Lombok annotations:\\n\\n- @Builder: Generates a builder-style constructor for this class. Allows creating instances with EingabeDings.builder().\\n\\n- @With: Generates withers (setter-like methods) for each field. Allows modifying fields after construction. \\n\\n- @Value: Indicates this class is immutable/read-only. No setter methods will be generated.\\n\\n- @Getter: Generates getter methods for each field. \\n\\nThe main() method:\\n\\n- Creates two Destination instances using the builder() method \\n- Calls toString() on the home instance\\n- Calls equals() to compare home and work\\n- Prints the country of home\\n- Prints the result of comparing home and work with equals()\\n\\nKey functions:\\n\\n- Builder constructor generated by @Builder\\n- Getter methods for fields generated by @Getter  \\n- Immutability of instances enforced by @Value\\n- Field comparison using equals() method\\n\\nThis demonstrates how Lombok can reduce boilerplate code for simple POJO/bean-like classes by generating common methods automatically based on its annotations.\&quot;,\&quot;/src/main/java/Objektvererbung/Einführung.java\&quot;:\&quot;This Java file introduces object-oriented inheritance in the Objektvererbung package.\\n\\nKey things it does:\\n\\n- Defines some classes that inherit from base classes:\\n  - Screen inherits from ElectronicDevice\\n  - Auto inherits from Fahrzeug \\n  - Motorrad inherits from Fahrzeug\\n- Creates instances of the classes and sets properties on them\\n- Defines print methods to output properties of the different classes\\n- Demonstrates polymorphism by passing different subclasses to the print methods\\n- Implements an interface (CanBeHifi) and sets the interface property on a Screen instance\\n\\nKey functions:\\n\\n- main() - Creates instances and calls print methods\\n- printElectronicDevice() - Prints an ElectronicDevice \\n- printAuto() - Prints an Auto and its specific properties\\n- printMotorrad() - Prints a Motorrad\\n- The classes like Screen, Auto, Motorrad with inherited properties\\n- Implements the CanBeHifi interface on a Screen\\n\\nSo in summary, it introduces object-oriented concepts like inheritance, polymorphism and interfaces using some example vehicle and electronic device classes.\&quot;,\&quot;/src/test/java/BastiBAufgaben/Geometry/CircleTest.java\&quot;:\&quot;This file contains JUnit tests for the Circle class in the BastiBAufgaben.Geometry package.\\n\\nKey things:\\n\\n- It is located in the src/test/java directory, which is the standard location for test code in a Maven project.\\n\\n- The package name matches the class being tested (BastiBAufgaben.Geometry). \\n\\n- It imports the JUnit test framework (org.junit.jupiter.api.Test).\\n\\n- It imports the Assertions class from JUnit to make assertions (static org.junit.jupiter.api.Assertions).\\n\\n- It has a single test method calculateArea() annotated with @Test.\\n\\n- The test creates a Circle with radius 4 using a builder. \\n\\n- It calls getArea() on the circle to get the actual result. \\n\\n- It makes an assertion comparing the actual area to the expected value of 50 using assertEquals().\\n\\nSo in summary, this file:\\n\\n- Contains JUnit tests for the Circle class\\n- Has a single test method calculateArea() \\n- Sets up a test Circle\\n- Executes the method under test\\n- Makes an assertion to validate the result\\n\\nIt is a basic example of a unit test for a single method on the Circle class.\&quot;,\&quot;/src/main/java/Objektvererbung/Interfaces/CanBeHifi.java\&quot;:\&quot;This Java file defines an interface called CanBeHifi.\\n\\nAn interface in Java defines a contract that classes can implement to provide certain functionality. Interfaces don\\u0027t provide implementations, they just define method signatures.\\n\\nThe CanBeHifi interface defines two method signatures:\\n\\n1. getHifi() - Returns a boolean indicating if the implementing class is hifi or not.\\n\\n2. setHifi(boolean hifi) - Sets whether the implementing class is hifi or not. Takes a boolean parameter to set the hifi state. \\n\\nKey things about this interface:\\n\\n- It defines a contract for classes to support hifi functionality \\n- Classes that implement this interface must provide implementations of getHifi() and setHifi()\\n- It doesn\\u0027t provide any implementation itself, just defines the method signatures\\n- Any class that implements this interface can then be checked for hifi capability via the getHifi() method\\n- Classes can have their hifi state set via the setHifi() method\\n\\nSo in summary, this interface defines a common hifi capability for classes to implement, without providing any implementation itself.\&quot;,\&quot;/src/main/java/Objektvererbung/Screen.java\&quot;:\&quot;This Screen.java file:\\n\\n- Defines a Screen class that extends the ElectronicDevice class\\n- Implements the CanBeHifi interface\\n- Stores resolutionX, resolutionY and inch properties to represent a screen\\u0027s resolution and size\\n- Gets/sets the resolutionX, resolutionY and inch properties\\n- Implements the isHifi() method from the CanBeHifi interface to check if the screen is hifi/high fidelity \\n- Implements the setHifi(boolean) method from CanBeHifi to set if the screen is hifi\\n- Stores a private hifi boolean property to track if the screen is hifi\\n- Provides a getHifi() method to retrieve the hifi property\\n\\nKey functions:\\n\\n- get/set methods for resolutionX, resolutionY, inch properties\\n- isHifi() method to check if screen is hifi\\n- setHifi(boolean) method to set the hifi property \\n- getHifi() method to retrieve the hifi property\\n- Inherits functions from ElectronicDevice class\\n- Implements CanBeHifi interface\\n\\nSo in summary, it defines a Screen class that represents a screen device with resolution/size properties and tracks if it is a hifi/high fidelity screen.\&quot;,\&quot;/src/main/java/Objektvererbung/MusicPlayer.java\&quot;:\&quot;This Java file defines a MusicPlayer class that implements the Playable interface.\\n\\nKey things:\\n\\n- It is in the Objektvererbung package\\n- Implements the Playable interface defined elsewhere \\n- Has a print() method that overrides the print() method from the Playable interface\\n- The print() method simply prints \\\&quot;spiel musik ab\\\&quot; which means \\\&quot;play music\\\&quot;\\n- So this class represents a music player object that can play music\\n- By implementing Playable, it agrees to provide the print() method that Playable requires\\n- The only method is print() which just outputs a message to indicate it is playing music\\n\\nSo in summary:\\n\\n- Defines a MusicPlayer class\\n- Implements Playable interface \\n- Overrides print() method from interface\\n- print() simply outputs a message to indicate playing music\\n\\nSo this allows MusicPlayer objects to be treated as Playable objects and provides the basic play functionality by printing a message.\&quot;,\&quot;/src/main/java/SilvanBonus/Raintrap.java\&quot;:\&quot;This Java file defines a class called Raintrap that contains a main method.\\n\\nThe key things it does:\\n\\n- Defines a class called Raintrap\\n- Contains a main method, which is the entry point for running the program\\n- Declares an integer array called trap with a length of 7\\n- Initializes some values in the trap array:\\n  - trap[0] \\u003d 0\\n  - trap[1] \\u003d 1 \\n  - trap[2] \\u003d 0\\n  - trap[3] \\u003d 2\\n  - trap[4] \\u003d 0\\n- Does not currently do anything else or have any other methods defined\\n\\nSo in summary:\\n\\n- Defines a Raintrap class \\n- Contains a main method for running the program\\n- Declares and initializes a trap integer array\\n- Currently just defines the array, more logic/methods would need to be added to do anything meaningful\\n\\nThe main purpose seems to be setting up an array to represent trap data, but no other logic has been implemented yet to utilize that array.\&quot;,\&quot;/src/main/java/Objektvererbung/Interfaces/Playable.java\&quot;:\&quot;This Java file defines an interface called Playable.\\n\\nKey things about it:\\n\\n- It is defined using the interface keyword, so Playable is an interface, not a class.\\n\\n- It is in the package Objektvererbung.Interfaces, indicating it defines an interface for object inheritance/polymorphism purposes. \\n\\n- It contains a single method declaration - public void print(). This means any class that implements the Playable interface must provide an implementation of this print() method.\\n\\n- The print() method has no access modifier like public or private, so it is implicitly public.\\n\\n- No method body is provided, just the signature. This is expected for interface methods since the implementation is left to the concrete classes.\\n\\n- It imports the VideoPlayer class, even though VideoPlayer is not used directly. This suggests VideoPlayer or some related class may implement this interface.\\n\\nSo in summary, this interface:\\n\\n- Defines a Playable type that can be printed \\n- Requires a print() method to be implemented by any conforming class\\n- Provides a contract for classes involved with playback that need a common print behavior\\n\\nThe key function is defining the print() method signature that implementers must provide.\&quot;,\&quot;/src/main/java/Objektvererbung/VideoPlayer.java\&quot;:\&quot;This Java file defines a VideoPlayer class that implements the Playable interface.\\n\\nKey things:\\n\\n- The VideoPlayer class is in the Objektvererbung package\\n- It implements the Playable interface defined in the Interfaces package\\n- There is a print() method that prints \\\&quot;spielt video ab\\\&quot; (plays video) when called\\n- By implementing Playable, VideoPlayer is agreeing to provide an implementation of the play() method defined in the Playable interface \\n\\nSo in summary:\\n\\n- Defines a VideoPlayer class\\n- Implements the Playable interface \\n- Has a print() method that outputs a message\\n- By implementing Playable, it can be used wherever a Playable object is expected\\n- Would need to provide an implementation of the play() method from Playable as well to be a fully functioning class\\n\\nSo it sets up a VideoPlayer object that can be treated as a Playable object and provides some basic functionality for playing a video.\&quot;,\&quot;/src/main/java/BastiBAufgaben/Geometry/usage.java\&quot;:\&quot;This Java file contains a main method that demonstrates how to use the Circle class defined in another file.\\n\\nThe key things it does:\\n\\n1. Creates a Circle object using the CircleBuilder pattern, setting the radius to 4. \\n\\n2. Calls the calculateArea() method on the circle to calculate and store the area. Prints out the area.\\n\\n3. Calls the calculateCircumference() method to calculate and store the circumference. Prints out the circumference. \\n\\n4. Calls the calculateDiameter() method to calculate and store the diameter. Prints out the diameter.\\n\\nSo in summary:\\n\\n- It creates a Circle object and sets the radius\\n- Calls methods to calculate the area, circumference and diameter \\n- Prints out the results\\n\\nThis allows testing and demonstrating the key functionality of the Circle class without needing additional code in that class file. The main method acts as an example of how to instantiate and use the Circle class.\&quot;,\&quot;/src/main/java/BastiBAufgabenShop/Shop.java\&quot;:\&quot;This Java file defines a Shop class that models an online shop.\\n\\nKey things it does:\\n\\n- Defines private ArrayList fields to store products (produkte) and customers (kunden)\\n\\n- Provides getter and setter methods to access/modify the product and customer lists\\n\\n- Has a constructor method OnlineShop() that initializes empty product and customer lists\\n\\nKey functions:\\n\\n- getProdukte() - Gets the list of products\\n- setProdukte() - Sets the list of products  \\n- getKunden() - Gets the list of customers\\n- setKunden() - Sets the list of customers\\n- OnlineShop() - Constructor that initializes empty lists\\n\\nSo in summary, it defines the basic data model and access methods for an online shop to store and retrieve its products and customer information.\&quot;,\&quot;/src/main/java/Objektvererbung/Bonus/Sortierer.java\&quot;:\&quot;This Java file contains a class called Sortierer that sorts Flugzeug objects based on their identification code (zc).\\n\\nThe key functions are:\\n\\n- main(String[] args) - The main method that runs the sorting logic\\n\\n- setZc(String zc) - Method on Flugzeug class to set the identification code \\n\\n- getZc() - Method on Flugzeug class to get the identification code\\n\\n- The sorting logic:\\n\\n  1. Creates some Flugzeug objects with sample IDs\\n\\n  2. Puts them in an array to be sorted\\n\\n  3. Loops through the array\\n\\n  4. Extracts the first character of the ID\\n\\n  5. Based on the character, extracts the second character and converts to an integer\\n\\n  6. Uses the integer to index into the target sorted array\\n\\n  7. Copies the Flugzeug object to the sorted array\\n\\n  8. Prints out the sorted array\\n\\nSo in summary, it takes some unsorted Flugzeug objects, extracts characters from their IDs, uses that to index and sort them into a target array, and prints out the sorted results.\&quot;,\&quot;/src/main/java/Objektvererbung/InterfacesBenutzen.java\&quot;:\&quot;This Java file demonstrates the use of interfaces:\\n\\n- It imports the Playable interface from the Interfaces package\\n\\n- It defines a main method that is the entry point of the program\\n\\n- It creates two objects:\\n  - MusicPlayer handy - MusicPlayer implements the Playable interface\\n  - VideoPlayer casette - VideoPlayer also implements Playable\\n\\n- The Playable interface defines common methods for playable media like play(), pause() etc. Even though MusicPlayer and VideoPlayer are different classes, by implementing the Playable interface they both can be treated as \\\&quot;playable\\\&quot; objects.\\n\\n- No methods are called on the objects, it just demonstrates that they can be instantiated since their classes implement Playable.\\n\\nKey things:\\n\\n- Imports and uses the Playable interface \\n- Defines a main method\\n- Creates objects of classes that implement Playable interface\\n- Demonstrates that different classes can share a common interface\\n\\nSo in summary, it shows a basic example of how interfaces can be used to define common behaviors for unrelated classes in Java.\&quot;,\&quot;/src/main/java/trycatch/example.java\&quot;:\&quot;This Java file contains an example program demonstrating try/catch exception handling:\\n\\nKey functions:\\n\\n- main() - The entry point of the program. Prints initial messages and calls vatermilch() function.\\n\\n- vatermilch() - Tries to call vaterHoltMilch() and catches any exceptions. Returns a string with the result. \\n\\n- vaterHoltMilch() - Throws an Exception to simulate an error occurring. This is caught in vatermilch().\\n\\nWhat it does:\\n\\n- Prints initial message that milk is empty\\n- Calls vatermilch() which tries to call vaterHoltMilch()\\n- vaterHoltMilch() throws an Exception \\n- The Exception is caught in the catch block of vatermilch()\\n- vatermilch() returns a string with the catch message\\n- main() prints the returned string and a conclusion\\n\\nIt demonstrates using try/catch to gracefully handle exceptions instead of the program crashing on error. The catch block returns an alternative message if the operation inside try throws an exception.\&quot;,\&quot;/src/main/java/Objektvererbung/media.java\&quot;:\&quot;This Java file defines a basic object-oriented media player application using inheritance.\\n\\nKey things it does:\\n\\n- Defines a base MediaController class that will control playback of different media types\\n- Defines MusicPlayer and VideoPlayer subclasses that inherit from a base Media class \\n- MusicPlayer and VideoPlayer define media-specific playback functionality\\n- The main method:\\n  - Creates a MediaController object\\n  - Creates MusicPlayer and VideoPlayer objects\\n  - Passes the different player objects to the MediaController\\u0027s playMedia method to playback different media\\n\\nKey functions:\\n\\n- MediaController class with playMedia method - This provides a common interface to playback different media types\\n- MusicPlayer and VideoPlayer subclasses - These define media-specific playback functionality by inheriting from a base Media class\\n- main method - Demonstrates polymorphism by passing different player objects to the controller to playback different media types\\n\\nSo in summary, it demonstrates a basic object-oriented media player design using inheritance and polymorphism to allow a single controller class to playback different media types defined as subclasses.\&quot;,\&quot;/src/main/java/Objektvererbung/Motorrad.java\&quot;:\&quot;This Motorrad.java file defines a Motorrad (Motorcycle) class that extends the Fahrzeug (Vehicle) class.\\n\\nKey things it does:\\n\\n- Extends the Fahrzeug class, so Motorrad inherits properties and behaviors from Fahrzeug\\n- Defines two additional properties specific to Motorrad:\\n  - Tires (int) - number of tires\\n  - Art (String) - type of motorcycle (e.g. sport bike, cruiser, etc.)\\n- Includes getter and setter methods for the Tires and Art properties\\n- Tires and Art are declared as instance variables at the bottom\\n\\nKey functions:\\n\\n- getTires() - Gets the Tires value \\n- setTires() - Sets the Tires value\\n- getArt() - Gets the Art value\\n- setArt() - Sets the Art value\\n\\nSo in summary, it defines a Motorrad class that inherits from Fahrzeug, and adds two additional properties (tires and type) specific to motorcycles, along with getter/setter methods for those properties. This allows Motorrad objects to be instantiated with motorcycle-specific attributes while still inheriting common vehicle behaviors.\&quot;,\&quot;/src/main/java/RecordsUndLombock/Course.java\&quot;:\&quot;This Java file defines a Course class that represents a course record. Here are the key things it does:\\n\\n- It is annotated with @Value from Lombok, which indicates this class is a value class. Lombok will generate getter methods, equals(), hashCode(), and toString() for it.\\n\\n- It defines three fields to represent a course - id (int), subject (Subject), and NumberOfStudents (int). \\n\\n- It has a constructor that takes a Subject as a parameter to initialize the subject field. \\n\\n- No other methods are defined, as Lombok will generate the standard getter methods.\\n\\n- It does not extend any other class or implement interfaces. \\n\\nSo in summary, this Course class:\\n\\n1. Defines a simple POJO to represent a course record\\n2. Uses Lombok annotations to reduce boilerplate code \\n3. Has fields to store id, subject, and number of students\\n4. Has a constructor to initialize the subject field\\n5. Lombok will generate standard getter methods, equals(), hashCode(), toString()\\n\\nSo the key functions are to define a simple value object for a course and reduce code verbosity with Lombok.\&quot;,\&quot;/src/main/java/Objektvererbung/Fahrzeug.java\&quot;:\&quot;This Java file defines a Fahrzeug (Vehicle) class that represents a basic vehicle object.\\n\\nKey things it does:\\n\\n- Defines properties for the vehicle - Hersteller (manufacturer), Modell (model), Baujahr (year of manufacture)\\n\\n- Getter and setter methods to access and set the property values \\n\\n- printData() method that prints out the Baujahr property\\n\\n- It is the base/parent class that other more specific vehicle classes (e.g. Car, Truck) can extend and inherit properties from\\n\\nKey functions:\\n\\n- getHersteller() - Gets the manufacturer \\n- setHersteller() - Sets the manufacturer\\n- getModell() - Gets the model\\n- setModell() - Sets the model  \\n- getBaujahr() - Gets the year of manufacture\\n- setBaujahr() - Sets the year of manufacture\\n- printData() - Prints out the year of manufacture\\n\\nSo in summary, it defines a basic Vehicle object with common properties and methods that other vehicle classes can inherit from.\&quot;,\&quot;/src/main/java/Main.java\&quot;:\&quot;This Java file contains a simple main method that prints \\\&quot;hi\\\&quot; to the console.\\n\\nKey things about this file:\\n\\n- It is located at src/main/java/Main.java, which is a common location for the main Java file in a Maven project structure.\\n\\n- The Main class contains the main method, which is the entry point for a Java application. \\n\\n- main() is a static method that can be called without creating an instance of the Main class.\\n\\n- main() takes a String array as a parameter, which will contain any command line arguments passed to the program.\\n\\n- It uses System.out.println() to print the string \\\&quot;hi\\\&quot; to the standard output stream (usually the console).\\n\\n- When run, it will execute the code inside main() which simply prints \\\&quot;hi\\\&quot;. No other functionality is implemented in this file.\\n\\n- It serves as a basic \\\&quot;Hello World\\\&quot; style Java file to demonstrate a minimal Java application with a main method that prints output.\\n\\nSo in summary, this file defines a Main class with a main() method that acts as the entry point for the application and prints a simple message to the console.\&quot;,\&quot;/src/main/java/RecordsUndLombock/Subject.java\&quot;:\&quot;This Java file defines an enum called Subject.\\n\\nKey things about it:\\n\\n- Subject is an enum, meaning it defines a fixed set of constants that represent possible values. Here the constants are MATH, IT, GERMAN.\\n\\n- Enums in Java are classes that extend the Enum class. So Subject is a class.\\n\\n- It defines 3 constants as possible values of the Subject type. \\n\\n- It has a String field called name. This allows each enum constant to have a name associated with it. \\n\\n- By default, enums provide things like name(), ordinal(), values() methods to work with the constants.\\n\\nSo in summary:\\n\\n- Defines an enum called Subject \\n- Subject represents a set of subject types as constants \\n- Contains 3 constants - MATH, IT, GERMAN\\n- Each constant can have a name associated via the name String field\\n- Provides default enum functionality like getting constants, names, etc.\\n\\nSo it establishes a type for representing subjects in a fixed set of possible values, with each value having a name associated to it via the name field.\&quot;,\&quot;/src/main/java/RecordsUndLombock/UniversityService.java\&quot;:\&quot;This file defines a UniversityService class in the RecordsUndLombock package.\\n\\nSome key things about this file:\\n\\n- It is located at src/main/java/RecordsUndLombock, which indicates it is a Java source file in the default package structure for a Maven project.\\n\\n- The class is public, so it can be accessed from other packages. \\n\\n- No fields or methods are defined yet. This is just an empty class definition to serve as a blueprint/template for a UniversityService.\\n\\n- The purpose of this class will likely be to encapsulate and provide business logic/services related to a university domain (e.g. managing students, courses, enrollments etc). \\n\\n- Key functions it may contain once implemented:\\n\\n  - Methods to retrieve/save/update university data like students, courses etc\\n\\n  - Business logic to handle university processes like enrollment, grading, transcripts etc\\n\\n  - Utilities to work with university data models\\n\\n  - APIs/interfaces for external systems to integrate with university services\\n\\nSo in summary, this file defines an empty service class blueprint that can be built out later with university domain specific business logic and data access functionality.\&quot;,\&quot;/src/main/java/Streams/Bonuuuus.java\&quot;:\&quot;This Java file reads in a CSV file containing student data and processes it using Java Streams.\\n\\nKey functions:\\n\\n- It opens a Stream from the students.csv file using Files.lines()\\n- It filters out the header line using line.equals() \\n- It filters out any null or empty lines\\n- It uses distinct() to remove any duplicate lines\\n- It maps each line to a Student object by splitting on comma and parsing values\\n- It prints out each Student object using forEach()\\n\\nSo in summary:\\n\\n- It reads a CSV file of student data\\n- Filters/cleans the data stream \\n- Maps each line to a Student object \\n- Prints out the stream of Student objects\\n\\nIt is using Java Streams to process the CSV file in a functional/declarative way rather than using loops or collections. The key steps are opening the stream, filtering, mapping and then consuming the stream.\&quot;,\&quot;/src/main/java/BastiBAufgabenShop/OnlineShop.java\&quot;:\&quot;This Java file defines an OnlineShop class that represents an online shop.\\n\\nKey things it does:\\n\\n- Defines a private static List called produktList to store Produkt objects. This acts as the inventory/catalogue of products for sale.\\n\\n- Defines a static objektHinzufügen method that adds a Produkt object to the produktList. This allows adding new products to the shop inventory. \\n\\n- produktList is static so it is shared across all instances of OnlineShop and maintains state about the products even if multiple OnlineShop objects are created.\\n\\nKey functions:\\n\\n- objektHinzufügen - Adds a new Produkt object to the shop inventory\\n- produktList - Stores the list of Produkt objects/products for sale \\n\\nSo in summary, it defines the basic data structure and functionality for an online shop to store a list of products for sale and allow new products to be added to the inventory. Other methods could be added for searching, retrieving products, checkout etc.\&quot;,\&quot;/src/main/java/BastiBAufgabenShop/meow.java\&quot;:\&quot;This Java file:\\n\\n- Defines a class called meow\\n- It does not appear to have any functions/methods defined\\n- It contains a single String field called hasihs\\n\\nKey things it does:\\n\\n- Defines a class called meow in the package BastiBAufgabenShop\\n- Declares a String field called hasihs to store a string value\\n- Does not define any methods or functions on the class\\n- Simply defines an empty class with a single string field\\n\\nSo in summary, it defines an empty class with a single string field to store a value, but does not implement any functionality itself. Likely just being used to define an object model/class without behavior implemented yet.\&quot;,\&quot;/pom.xml\&quot;:\&quot;This pom.xml file is the project object model (POM) file for a Maven Java project.\\n\\nThe key functions of this pom.xml file are:\\n\\n- Defines the project metadata like groupId, artifactId, version etc. This identifies the project.\\n\\n- Specifies the Java source and target versions to use for compilation.\\n\\n- Defines dependencies on external libraries like Lombok and JUnit that the project needs. This allows Maven to download these dependencies. \\n\\n- Tells Maven this is a Maven project and which version of the Maven POM schema to use.\\n\\n- Allows building the project with Maven commands like mvn package, mvn test etc by providing the necessary configuration.\\n\\n- Manages the project lifecycle and coordinates tasks like compiling, testing, packaging etc.\\n\\n- Centralizes project configuration settings like encoding, plugins etc in one place.\\n\\nSo in summary, it provides the necessary configuration for Maven to build, test and manage the project and its dependencies. Maven reads this file to execute tasks on the project.\&quot;,\&quot;/src/Ecosystem-exception-task-main/pom.xml\&quot;:\&quot;This is a pom.xml file which is used by Maven to manage the build of a Java project.\\n\\nKey functions of this pom.xml file:\\n\\n- Defines the project coordinates like groupId, artifactId, version which uniquely identify the project.\\n\\n- Specifies the Java version (source and target) to use for compilation. \\n\\n- Defines dependencies on other libraries like Lombok in this case. Lombok provides annotations to reduce boilerplate code.\\n\\n- Tells Maven this is a Maven project and which version of the Maven POM schema to use. \\n\\n- Manages the build lifecycle and configuration. For example it will download dependencies, compile code, run tests etc. based on Maven build phases.\\n\\n- Acts as the central configuration file for the project that manages build, reporting, documentation etc. \\n\\n- Allows easy sharing of the project configuration across development machines by checking this file into version control.\\n\\nSo in summary, it defines the project metadata and manages the build, dependencies and lifecycle using Maven.\&quot;,\&quot;/src/main/java/Objektvererbung/ElectronicDevice.java\&quot;:\&quot;This Java file defines a base ElectronicDevice class that other electronic device classes can inherit from.\\n\\nKey points:\\n\\n- It defines an ElectronicDevice class with private fields for price, energy consumption in watts, and name.\\n\\n- It has getter and setter methods for each field to allow accessing and modifying the field values. \\n\\n- The getter methods return the field values without modifying them.\\n\\n- The setter methods allow modifying the field values.\\n\\n- This allows subclasses to inherit these common fields and methods to represent basic electronic device properties like price, energy usage, and name.\\n\\n- Subclasses can then add their own specific fields and methods on top of this base class.\\n\\nSo in summary, this base ElectronicDevice class provides a template for representing common electronic device attributes that subclasses can build upon for specific device types. The key functions are the getter and setter methods to access and modify the common price, energy, and name fields.\&quot;,\&quot;/src/main/java/Streams/Student.java\&quot;:\&quot;This Student.java file defines a Student class that represents a student object.\\n\\nKey things it does:\\n\\n- Defines fields to store student data - part, part1, part2 strings and an int i\\n\\n- Has a constructor that initializes the fields when a new Student object is created\\n\\n- Overrides the toString() method to define how Student objects will be printed/converted to a String \\n\\n- The toString() method returns a String containing the field values formatted nicely \\n\\n- Allows Student objects to be created and their field values accessed via getters\\n\\n- Provides a way to represent a Student as a String for output/logging purposes\\n\\nSo in summary, it defines a basic Student class/object that can hold student data like name, id etc. and provides a way to create Student objects and access/print their field values. This allows student data to be represented and worked with as objects in code using this class.\&quot;}&quot;}" />
  </component>
</project>